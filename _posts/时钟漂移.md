# 时钟漂移

在看 Etcd-Raft 的源码的时候，注意到了Raft中有个 ReadOnlyOption 的选项
在 ReadOnlyOtpition 的状态中有两种， 一种是ReadOnlySafe， 一种是ReadOnlyLeaseBased。
其中 ReadOnlyLeaseBased 的描述中提到了Clock Drift。去网上查了一下关于Clock Drift的定义。
参考： [http://www.beaglesoft.com/Manual/page75.htm](http://www.beaglesoft.com/Manual/page75.htm)

简单的翻译如下：
在每一台AT-compatible的电脑中，内置了两种时钟。这两种时钟根据不同的情况有很多种命名区分，我在这里我们简单的以硬件时钟和软件时钟作为区别。软件时钟只在电脑开启的时候运行，当电脑关机的时候停止。硬件时钟靠电池运行，当电脑关机的时候也运行着。（TODO 没电的时候怎么运行？台式机断电了怎么运行？）

每台装有DOS或者Windows的电脑内置了一个软件时钟（TODO Linux的系统没有提及到？）在PC或者XT-compatibles的电脑上，intel 8253时钟计数器chip（不知道怎么翻译）或者一个等同的设备来驱动这个时钟。AT-Compatible的电脑用intel 8254时间计数器或者等同的设备来驱动。时钟计数被BIOS设计成每隔54.936ms或者18.206每次每秒中断一次。另一个BIOS routine(翻译成进程？)统计中断的请求，然后生成一个以一天为单位的时钟提供给软件读写。e.g. Windows用软件时钟的时间戳来操作文件。

软件时钟很有用，但是有一些局限。第一，软件时钟是一个poor timekeeper（不知道怎么翻译了）。他的准确性受到统计中断数量的稳定性。任何可以影响中断频率的事都会导致软件时钟的数量增加或者减少。当电脑开机很久了，软件时钟也许会有很大的偏差，可能会有一天一分钟以上的时间差。有部分恶意软件可以通过改变中断频率改变。这个也可能导致软件时间的增加或者减少。

另一个问题是当软件时钟不能显示完全一天的时钟。解决的办法是限制两次中断之间的间隔长度，大概55毫秒或者更早。只有在这个间隔倍数的时间才能显示出来。e.g. 00:00:01.00不会被展示出来，最近的时间戳是00:00:00.98或者00:00:01.04。

然而软件时钟最大的限制是当电脑关机后，软件时钟停止计数。在IBM-PC原型机上（不知道是不是这个翻译），这就意味着你每次开机后都必须手动去设置软件时钟。可以为电脑购买另一个带电源的时钟，但是那就是几个不同的模式了。

简单的总结一下：
软件时钟是靠统计中断次数来实现记录时间的，没次中断的间隔是差不多固定的。所有这就导致了两个主要问题：一是如果电脑的中断频率被其他影响有所改变（包括BIOS程序自身和恶意的程序），软件时钟的时间就会改变；二是时间是中断频率的整数倍，导致没法展示所有的时间，比如间隔时间x1+0.1这种的时间就没法展示。三是电脑关机后软件时间就停止计数了，以前必须要手动设置，现在应该不会了。

TODO：
在Java/Go代码里面获得的时间戳是软件时间还是硬件时间
时钟漂移会影响Java定时任务吗