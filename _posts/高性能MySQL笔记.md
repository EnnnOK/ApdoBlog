# 高性能MySQL读书笔记

## 第四章 Schema与数据类型优化
1. 数据类型小的比大的更好（tiniint比int好）；简单的比复杂更好（整型比浮点好）；数据库自带的比自定义的好（用date存时间比用字符存时间好）；这些都很好理解，数据在硬盘里存储的越简单各种操作也就越快。
2. timestamp与datetime类型都可以精确到秒，但是timestamp比datetime小一半存储，查起来也更快；但是有时候用timestamp会遇到范围问题。timestamp不能存unix时间戳0s以前的时间，这个很好理解，因为不能存副职，最大只能到2038年，因为timestamp用的是4个字节的空间。（TODO：计算一下。）
3. 有符号的整型和无符号的整型，如果存的范围一样，那么效率也一样。
4. varchar是变长字符串，比char可以节约部分长度。使用varchar的最佳场景：存放数据的最长字符串和平均字符串差距不太大，就是(max-min)比较小（长度比较平均分布，方差较小？），因为varchar会以最长字符的长度作为长度。char适合存定长的字符，比如加盐之后的数据，char性能很好。
5. BIT 、SET 仔细研究
6. 存放ip地址类型可以用整型而不是字符串，这个很好理解，因为ip地址本来就是一个整数，只不过通过.号来划分便于标示，可以通过MySQL自带的函数来进行转换，即使没有转换，在代码里面转换一下也很简单。

## 第五章 创建高性能的索引
这里只关注InnoDB，因为InnoDB用的最多，支持索引和事物，为了减少开发中可能遇到的问题以及遇到问题减少踩坑成本，用InnoDB比较好。对DB性能要求到了极致的话，就不用了。	
1. InnoDB引擎采用的是B+Tree，适用于全键值匹配，键值范围查找和前缀查找。前面两个都很好理解，通过B+Tree可以很快的找到一个节点的值，或者一个节点范围的值，直接把这些值拿出来就得到了，前缀查找还没用过。order by group by也可以用B+Tree。
2. B+Tree可以用来精确查找索引列并范围查找另一列，不能精确查找索引列并精确查找另一个列。例如 
```sql
where index_col = "test" and other_col like 'other' /*可以*/
where index_col = "test" and other_col = "other" /*不可以*/
```
3. Hash索引只能等值查询，这个很好理解，hash后的值在hash表中是分散的不是顺序的，没法排序和范围查询。Hash索引查询很快，因为直接计算得到hash表中的位置。但是当Hash冲突很大的时候，速度会变慢，具体的会应该要看Hash冲突后是用怎么解决的，链表还是树，可以对照Java HashMap的实现。
4. TODO 学习形树索引（fractal tree index）
5. 比较长的数据可以用前缀索引，提高效率。前缀索引的长度可以通过测试大概计算出。
6. IN条件查询的时候，MySQL会先将里面的数据排序，然后用范围查询方式提高查询效率。TODO：确认是否只针对B+TREE，Oracle，PostgreSQl使用IN条件查询的时候什么情况。
7. TODO 多列索引少条件能不能用。

## 第六章 查询性能优化
1. 查看sql是否有问题，查询返回多的列，多表关联查询的时候返回了所有列的数据。
2. 查看sql语句执行扫描的行数和返回的行数。
3. 查看复杂的sql能否分开成简单的sql然后高效利用索引。TODO where 多条件索引查询 然后分开查询测试。
4. 将关联查询分开来执行。
