# 基于索引的代码复制检测
 > 翻译来源于 [Index-Based Code Clone Detection: Incremental, Distributed, Scalable](http://www4.in.tum.de/~juergens/publications/icsm2010_crc.pdf) 

这段介绍了可以针对超大型的代码可以增长和扩张的代码检测方式。

## A. 结构
在这，会描述出基于索引的代码赋值检测的结构，指出其结构和区别于其他方法的代码。

复制检测流水线：复制检测由一系列过程组成，每个过程的构建包含了上一个过程的结构。

预处理阶段：从硬盘阅读源代码，然后将其划分成token组成。这个过程需要标准化，移除代码中微小的不同，比如像包含注释以及变量名等。
标准化影响着精度和代码检测的结果。标准化的结果被分成组放进statement里。每个文件的处理结果是一系列标准化的statement。

检测阶段：搜索全局的statement列表。对于相等的子字符串搜索全局的statement列表，
搜索的结果是影响到结果的层级。

处理后阶段 从标准化的statements的复制层级信息中创建出复制区域信息。因此，取决于复制检测的场景，复制检测可以被过滤掉，展示在面板上或是以报告的形式交互式的展现在IDE上。

性能参数： 在预处理阶段的任务（从磁盘阅读，扫描，标准化）的时间复杂度是线性的，空间复杂度是关于输入文件的长度的。因此，预处理阶段是可以平行处理的，因为每个文件都可以独立的处理。算法的瓶颈取决于复制检测阶段，尤其是扩展的如何影响到增长，因此算法着重在于检测阶段。
基于索引的复制检测，因此，表现出了对于小说的复制检测方法。对于预处理和处理后阶段，两者都。

### B 复制索引
这段将会展示出检测算法里面最核心的数据结构，复制索引。复制索引使得我们能够查询单个文件的所有复制（同样适用于整个系统），当文件被增加，移除或者修改的时候，可以有效的更新。

一个系统的所有复制列表不是可以全部被复制索引所替代，因此有效的更新是不可能的。增加一个新的文件可能会潜在的引入已经存在的文件的新的复制，因此在没有其他数据结构使用的情况下对比所有的文件是有必要的。

复制索引的关键点与用在文件检索系统的反向索引相似。在那里，每个单词和其出现的地方相映射。同样的，复制索引维护这标准的语句和其出现的映射关系。更准确的一点，复制索引是一个元祖的列表，其中：
文件： 是文件的名字；
语句索引： 代表了文件中语句出现在标准语句列中的的位置编号
系列hash： 是从语句索引开始后面n条语句的的hash值。（n是一个常数，代表块长度，用于设置最小的复制检测行）

信息： 包含了一些其他的信息，是算法里面不包含的。但是可能在处理后的报告展示阶段会有用到。

复制索引包含了全部文件的全部语句块。对于单个文件，(1,...,n), (2,...,(n+1)), (3,...,(n+ 2)) 等等 被排列起来。检测算法需要变量每个元组通过文件和短hash，因此，两种都需要被有效的支持。除此之外，复制索引结构体中没有其他的限制了。这种情况下，取决于不同的实际场景，这里会有很多种不同的实现算法。这里的基于内存的使用两张hash表或者搜索树用于查找，基于硬盘使用。

在图1里面，对于输入文件 X.j 和其对于其块长度为5的复制索引的关系被可视化的展现出来。整个里面需要最多的解释的就是sequence hash值整个字段了。在这里索引中使用语句的序列来代替独立的语句使用因为，语句系列可能更家不同。两个不同的语句系列和一个语句比起来坑你更加不同。因此可以更加不同的比较复制。如果在索引里面有两个不同的实体但是有相同的序列，我们就已经拥有了长度为n的复制。使用hash替代整个语句的原因为了节省空间。这种方法和n的选择是独立的，索引我们会选择更短内容对于有相同值的n。这里采用MD5hash算法。

C. 复制检索
复制检索的过程是从单个文件中提取来所有的复制。一般情况下，我们假设文件已经包含在了所以那里面，但是同样的过程可以被用来查找索引和已经存在的文件中的复制。元组已经被只是分成量了长度至少为n（n代表了全局的块长度）复制检索的目标是至报告最大的重复，也就是说所有的包含了没有被另一个复制组所包含。纵览整个算法，是计算出最长的重复代码系列，图二战术出来了更多的细节。

第一步是创建出来一个列表c包含了所有的重复代码块。整个列表里包含了文件全部的元祖，其中元祖的序列hash值和已经在文件中发现的序列hash值相同。索引被用来去接入每个文件的索引的和每个文件的响应。开始工作的如图三的展示。其中对于X.j有长度为10的复制，（6个长度为5的元祖），对于Y.j和Z.j文件有长度为7的重复。

在主循环中，首先检查是有有新的复制从这一行开始。如果这个元祖对于这个hash值只有一个元祖，我们就跳出这个循环的迭代。同样的情况发生在如果元祖对于i的位置已经出现有i-1出现在过了。对于这种情况，所有i开始的原则都已近被包括在了i-1开始的元祖中。虽然在这里使用了子集操作符，但是其实并不是真正的自己操作。因为元祖中c(i)的语句索引会比c(i-1)的增加1，相关的hash值字段和info字段也会有所差异。

第十行引入的集合a被称作激活结婚，其中包括了所有的没有被报告的复制。对于每次内部的迭代
// todo
